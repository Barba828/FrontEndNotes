# 垃圾回收机制

GC（Garbage Collection，垃圾回收）是一种内存自动管理机制， 垃圾回收器（Garbage Collector）可以自动回收分配给程序的已经不再使用的内存。

- 常见的 GC 算法有引用计数法和标记清除法等。
- V8（JavaScript 引擎，提供执行 JavaScript 的运行时环境）的垃圾回收器算法主要由 Mark-Compact 和 Scavenger 构成。

## 内存泄漏

内存泄漏是指，应当被回收的对象没有被正常回收，变成常驻老生代的对象，导致内存占用越来越高。内存泄漏会导致应用程序速度变慢、高延时、崩溃等问题。

### 内存生命周期 ​

1. 分配：按需分配内存。
2. 使用：读写已分配的内存。
3. 释放：释放不再需要的内存。

### 内存泄漏常见原因 ​

1. 创建全局变量，且没有手动回收。
2. 事件监听器 / 定时器 / 闭包等未正常清理。
3. 使用 JavaScript 对象来做缓存，且不设置过期策略和对象大小控制。

## 垃圾回收方法

### 1.引用计数法 Reference-Counting​

Reference Counting 是常见的垃圾回收算法，其核心思路是：将资源（比如对象）的被引用次数保存起来，当被引用次数为零时释放。
该方法的局限性：当出现循环引用时，互相引用的对象不会被回收。

### 2.标记清除法 Mark-Sweep

JavaScript 最常用的垃圾收集方式。当变量进入环境时，这个变量标记为“进入环境”；而当变量离开环境时，则将其标记为“离开环境”。可以使用一个“进入环境”的变量列表及一个“离开环境”的变量列表来跟踪变量的变化，也可以翻转某个特殊的位来记录一个变量何时进入环境及离开环境。

### V8 垃圾清理

V8 中有两个垃圾收集器。主要的 GC 使用 Mark-Compact 垃圾回收算法，从整个堆中收集垃圾。小型 GC 使用 Scavenger 垃圾回收算法，收集新生代垃圾。

两种不同的算法应对不同的场景：

- 使用 Scavenger 算法主要处理存活周期短的对象中的可访问对象。
- 使用 Mark-Compact 算法主要处理存活周期长的对象中的不可访问的对象。

因为新生代中存活的可访问对象占少数，老生代中的不可访问对象占少数，所以这两种回收算法配合使用十分高效。

#### 分代回收

原因：绝大多数对象的生存期很短，只有某些对象的生存期较长
过程：

1. 对象起初会被分配在新生区（通常很小，只有 1-8 MB）在新生区的内存分配非常容易：我们只需保有一个指向内存区的指针，不断根据新对象的大小对其进行递增即可。当该指针达到了新生区的末尾，就会有一次清理（小周期 Scavenger），清理掉新生区中不活跃的死对象。
2. 活跃超过 2 个小周期的对象，则需将其移动至老生区老生区在标记－清除或标记－紧缩（大周期 Mark-Compact）的过程中进行回收。大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生。至于足够多到底是多少，则根据老生区自身的大小和程序的动向来定。

#### Mark-Compact 算法（Major GC）

Mark-Compact 算法可以看作是 Mark-Sweep（标记清除）算法和 Cheney 复制算法的结合。该算法主要分为三个阶段：标记、清除、整理。

1. 标记（Mark）
   标记是找所有可访问对象的过程。GC 会从一组已知的对象指针（称为根集，包括执行堆栈和全局对象等）中，进行递归标记可访问对象。
2. 清除（Sweep）
   清除是将不可访问的对象留下的内存空间，添加到空闲链表（free list）的过程。未来为新对象分配内存时，可以从空闲链表中进行再分配。
3. 整理（Compact）
   整理是将可访问对象，往内存一端移动的过程。主要解决标记清除阶段后，内存空间出现较多内存碎片时，可能导致无法分配大对象，而提前触发垃圾回收的问题。

#### Scavenger 算法（Minor GC）

V8 对新生代内存空间采用了 Scavenger 算法，该算法使用了 semi-space（半空间） 的设计：将堆一分为二，始终只使用一半的空间：From-Space 为使用空间，To-Space 为空闲空间

1. 新生代在 From-Space 中分配对象；
2. 在垃圾回收阶段，检查并按需复制 From-Space 中的可访问对象到 To-Space 或老生代，并释放 From-Space 中的不可访问对象占用的内存空间；
3. 最后 From-Space 和 To-Space 角色互换。
