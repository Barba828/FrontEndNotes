# HTTP 缓存机制

[MDN HTTP 缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)

HTTP 缓存主要分为**强缓存**和**协商缓存**。

- 强缓存可以通过 Expires / Cache-Control 控制，命中强缓存时不会发起网络请求，资源直接从本地获取，浏览器显示状态码 200 from cache。
- 协商缓存可以通过 Last-Modified / If-Modified-Since 和 Etag / If-None-Match 控制，开启协商缓存时向服务器发送的请求会带上缓存标识，若命中协商缓存服务器返回 304 Not Modified 表示浏览器可以使用本地缓存文件，否则返回 200 OK 正常返回数据。

![流程图](https://user-images.githubusercontent.com/13888962/125894860-a0b9eecd-03b6-49ce-9612-9705b1fb6e78.png)

## 1.强缓存

### Expires​

- HTTP/1.0 产物。
- 优先级低于 Cache-control: max-age。
- 缺点：使用本地时间判断是否过期，而本地时间是可修改的且并非一定准确的。
  Expires 是由服务端返回的资源过期时间（GMT 日期格式/时间戳），若用户本地时间在过期时间前，则不发送请求直接从本地获取资源。

### Cache-Control​

- HTTP/1.1 产物。
- 优先级高于 Expires。
- 正确区分 no-cache / no-store 的作用。

Cache-Control 是用于页面缓存的通用消息头字段，可以通过指定指令来实现缓存机制。

常用的字段有：

- no-cache 强制客户端向服务器发起请求（禁用强缓存，可用协商缓存）。
- no-store 禁止一切缓存，包含协商缓存也不可用。
- public 表示响应可被任何对象缓存。
- private 表示响应只可被私有用户缓存，不能被代理服务器缓存。
- max-age 设置缓存存储的最大时长，单位秒。
- s-max-age 与 max-age 用法一致，不过仅适用于代理服务器。
- must-revalidate 一旦资源过期，在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。
- immutable 表示响应正文不会随时间改变（只要资源不过期就不发送请求）。

值得注意的是，虽然以上常用字段都是响应头的字段，但是 Cache-Control 同时也支持请求头，例如 Cache-Control: max-stale=<seconds> 表明客户端愿意接收一个已经过期但不能超出<seconds>秒的资源。

### 拓展知识（冷门考点）​

- HTTP/1.0 Pragma
  - 在 HTTP/1.0 时期用于禁用浏览器缓存 Pragma: no-cache。
- 缓存位置
  - 从 Service Worker 中读取缓存（只支持 HTTPS）。
  - 从内存读取缓存时 network 显示 memory cache。
  - 从硬盘读取缓存时 network 显示 disk cache。
  - Push Cache（推送缓存）（HTTP/2.0）。
  - 优先级 Service Worker > memory cache > disk cache > Push Cache。
- 最佳实践
  - 资源尽可能命中强缓存，且在资源文件更新时保证用户使用到最新的资源文件
  - 强缓存只会命中相同命名的资源文件。
  - 在资源文件上加 hash 标识（webpack 可在打包时在文件名上带上）。
  - 通过更新资源文件名来强制更新命中强缓存的资源。

## 2.协商缓存 ​

### ETag / If-None-Match​

- 通过唯一标识来验证缓存。
- 优先级高于 Last-Modified / If-Modified-Since。

如果资源请求的响应头里含有 ETag，客户端可以在后续的请求的头中带上 If-None-Match 头来验证缓存。若服务器判断资源标识一致，则返回 304 状态码告知浏览器可从本地读取缓存。
唯一标识内容是由服务端生成算法决定的，可以是资源内容生成的哈希值，也可以是最后修改时间戳的哈希值。所以 Etag 标识改变并不代表资源文件改变，反之亦然。

### Last-Modified / If-Modified-Since​

- 通过资源的最后修改时间来验证缓存。
- 优先级低于 ETag / If-None-Match。
- 缺点：只能精确到秒，若 1s 内多次修改资源 Last-Modified 不会变化。

如果资源请求的响应头里含有 Last-Modified，客户端可以在后续的请求的头中带上 If-Modified-Since 头来验证缓存。若服务器判断资源最后修改时间一致，则返回 304 状态码告知浏览器可从本地读取缓存。

### 拓展知识

ETag 在标识前面加 W/ 前缀表示用弱比较算法（If-None-Match 本身就只用弱比较算法）。
ETag 还可以配合 If-Match 检测当前请求是否为最新版本，若资源不匹配返回状态码 412 错误（If-Match 不加 W/ 时使用强比较算法）。

## 3.缓存的优缺点 ​

缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。

#### 优点

- 节省了不必要的数据传输，节省带宽。
- 减少服务端的负担，提高网站性能。
- 降低网络延迟，加快页面响应速度，增强用户体验。

#### 缺点

-不恰当的缓存设置可能会导致资源更新不及时，导致用户获取信息滞后。

# HTTP/1.1 和 HTTP/2

HTTP/1.1 相较 HTTP/1.0 的改进和优化：

- 持久连接
- HTTP 管道化
- 分块编码传输
- 新增 Host 头处理
- 更多缓存处理
- 新增更多状态码
- 断点续传、并行下载

HTTP/1.1 的缺点：

- 队头阻塞（Head-of-line blocking）
- 头部冗余
- TCP 连接数限制

HTTP/2 的优点：

- 二进制分帧层
- 多路复用
- Header 压缩
- 服务端推送

## 1. HTTP/1.1​

### 1.1 相较 HTTP/1.0 的改进和优化 ​

HTTP/1.1 相比于 HTTP/1.0 的改进和优化主要包含：持久连接、HTTP 管道化请求、分块编码传输、新增 host 头字段、缓存支持、更多状态码等。

#### 持久连接

在 HTTP/1.0 时期，每进行一次 HTTP 通信，都需要经过 TCP 三次握手建立连接。若一个页面引用了多个资源文件，就会极大地增加服务器负担，拉长请求时间，降低用户体验。

HTTP/1.1 中增加了持久连接，可以在一次 TCP 连接中发送和接收多个 HTTP 请求/响应。只要浏览器和服务器没有明确断开连接，那么该 TCP 连接会一直保持下去。

持久连接在 HTTP/1.1 中默认开启（请求头中带有 `Connection: keep-alive`），若不需要开启持久连接，可以在请求头中加上 Connection: close。

#### HTTP 管道化

HTTP 管道化是指将多个 HTTP 请求同时发送给服务器的技术，但是响应必须按照请求发出的顺序依次返回。

但是由于 HTTP 管道化仍存在诸多问题：

- 第一个响应慢仍会阻塞后续响应
- 服务器为了保证能按序返回需要缓存提前完成的响应而占用更多资源
- 需要客户端 、代理和服务器都支持管道化

所以目前大部分主流浏览器默认关闭 HTTP 管线化功能。

#### 分块编码传输

在 HTTP/1.1 协议里，允许在响应头中指定 `Transfer-Encoding: chunked` 标识当前为分块编码传输，可以将内容实体分装成一个个块进行传输。

#### 新增 Host 头处理

在 HTTP/1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此一台服务器也无法搭建多个 Web 站点。

在 HTTP/1.1 中新增了 host 字段，可以指定请求将要发送到的服务器主机名和端口号。

#### 断点续传、并行下载

在 HTTP/1.1 中，新增了请求头字段 `Range` 和响应头字段 `Content-Range`。

前者是用来告知服务器应该返回文件的哪一部分，后者则是用来表示返回的数据片段在整个文件中的位置，可以借助这两个字段实现断点续传和并行下载。

### 1.2 HTTP/1.1 的缺点 ​

#### 队头阻塞(Head of line blocking)

虽然在 HTTP1.1 中增加了持久连接，能在一次 TCP 连接中发送和接收多个 HTTP 请求/响应，但是在一个管道中同一时刻只能处理一个请求，所以如果上一个请求未完成，后续的请求都会被阻塞。一般会使用到雪碧图、使用多个域名等方式来优化性能。

#### 头部冗余

HTTP 请求每次都会带上请求头，若此时 cookie 也携带大量数据时，就会使得请求头部变得臃肿。

#### TCP 连接数限制

浏览器对于同一个域名，只允许同时存在若干个 TCP 连接（根据浏览器内核有所差异），若超过浏览器最大连接数限制，后续请求就会被阻塞。

## 2. HTTP/2​

HTTP/2 也被称为 HTTP 2.0，相对于 HTTP 1.1 新增了多路复用、压缩 HTTP 头、划分请求优先级和服务端推送等特性，解决了在 HTTP 1.1 中一直存在的问题，优化了请求性能，同时兼容了 HTTP 1.1 的语义

### 2.1 HTTP/2 的优点 ​

#### 二进制协议(二进制分帧层)

在 HTTP/1.x 中传输数据使用的是纯文本形式的报文，需要不断地读入字节直到遇到分隔符为止。而 HTTP/2 则是采用二进制编码，将请求和响应数据分割为一个或多个的体积小的帧。基于二进制可以使协议有更多的扩展性，例如引入帧来传输数据和指令。

#### 多路复用(MultiPlexing)

基于二进制分帧层，HTTP2.0 可以在共享的单个 TCP 连接的基础上同时发送请求和响应，在另一端根据流标识符和首部将他们重新组装起来，极大提高传输性能，真正解决了 HTTP/1.1 的队头阻塞和 TCP 连接数限制问题。

#### Header 压缩(Header compression)

HTTP 请求头带有大量信息，而且每次都要重复发送。HTTP/2 采用 HPACK 格式进行压缩传输，通讯双方各自缓存一份头域索引表，相同的消息头只发送索引号，从而提高效率和速度。

#### 服务端推送(Server Push)

允许服务端主动向浏览器推送额外的资源，不再是完全被动地响应请求。例如客户端请求 HTML 文件时，服务端可以同时将 JS 和 CSS 文件发送给客户端。
