## OSI七层网络模型

| 层     | 功能 | TCP/IP协议族 |
| ------ | :--: | -----------: |
| 应用层 | 文件传输，电子邮件，文件服务，虚拟终端 |         TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet |
| 表示层 | 数据格式化，代码转换，数据加密  |         没有协议 |
| 会话层 | 解除或建立与别的接点的联系  |         没有协议 |
| 传输层 | 提供端对端的接口 TCP，UDP |         TCP，UDP |
| 网络层 | 为数据包选择路由 |         IP，ICMP，RIP，OSPF，BGP，IGMP  |
| 数据链路层 | 传输有地址的帧以及错误检测功能 |         SLIP，CSLIP，PPP，ARP，RARP，MTU  |
| 物理层 | 以二进制数据形式在物理媒体上传输数据 |  ISO2110，IEEE802，IEEE802.2 |

### TCP/UDP协议

TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。其中TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复 用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；而UDP则不为IP提供可靠性、 流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。TCP支持的应用协议主要 有：Telnet、FTP、SMTP等；UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系 统）、TFTP（通用文件传输协议）等.
TCP/IP协议与低层的数据链路层和物理层无关，这也是TCP/IP的重要特点

## TCP/IP

### TCP/IP连接三次握手：  

- 第一次握手：客户端发送一个SYN包给服务器，表示请求连接；
- 第二次握手：服务器发送SYN+ACK包给客户端，表示收到你的请求，并同意连接（服务端确认：客户端发送消息正常；客户端确认：客户端消息发送正常，客户端消息接收正常，服务端消息发送正常，服务端消息接收正常）；
- 第三次握手：客户端发送确认包ACK给服务器，表示确认并开始连接（服务端确认：客户端接收消息正常，服务端发送消息正常，服务端接受消息正常）。
三次握手即可在双端确认：自己和对方消息发送和接收正常。

### TCP/IP断开四次挥手：

- 第一次挥手：客户端发送一个FIN包给服务器，表示将要关闭客户端到服务器这个方向的连接；
- 第二次挥手：服务器发送一个ACK包给客户端，表示同意客户端关闭连接的请求，但还没有准备好关闭连接；
- 第三次挥手：服务器发送一个FIN包给客户端，表示将要关闭服务器到客户端这个方向的连接；（这一步和握手不同，握手ACK+SYN可以一起发送，而挥手先发送ACK应答关闭，在报文发送完成后才发送FIN表示现在才可以关闭）
- 第四次挥手：客户端发送一个确认包ACK给服务器，表示确认并关闭连接。

#### 注：
SYN：同步序列编号（Synchronize Sequence Numbers)；seq: Sequence number(顺序号码);ACK(Acknowledgement)是标识位;ack(Acknowledgement Number),是确认号。seq为什么要随机，主要是出于网络安全的因素着想。如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，并且伪造序列号进行攻击，这已经成为一种很常见的网络攻击手段。

### 为什么TCP建立连接需要三次握手，而断开连接需要四次挥手？

　　因为当服务器收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务器端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到服务器端所有的报文都发送完了，服务器才能发送FIN报文，因此不能一起发送，故需要四步握手。

### 从输入一个URL到浏览器加载整个网页的过程？

1. 浏览器通过DNS服务器解析查找URL对应的IP地址；
2. 浏览器向服务器发送http请求，建立TCP连接；
3. 服务器响应并处理http请求，返回相应的文件；
4. 浏览器开始处理数据信息，并渲染页面，显示出来。

### TCP/IP 五层模型中对应的协议有哪些？
将OSI七层模型的应用层、表示层、回话层表示为应用层
- 应用层：HTTP（超文本传输协议）、FTP（文件传送协议）、SMTP（简单邮件传送协议）
- 运输层：TCP（传输控制协议）、UDP（用户数据报协议）
- 网络层：IP（网际协议）、ICMP（网际控制报文协议）
- 数据链路层：PPP（点对点协议）、CSMA/CD（载波监听多点接入/碰撞检测协议）
- 物理层：IEEE802系列（局域网与城域网系列标准协议）

### TCP与UDP的区别？

1. TCP是面向连接的协议，UDP是无连接协议；
2. TCP是可靠、有序、无界的，而UDP不可靠、无序、有界；
3. TCP有流量控制（拥塞控制），而UDP 没有；
4. TCP传输速度慢，而UDP传输速度快；
5. TCP是重量级的，UDP是轻量级的，TCP的头部比 UDP大；
6. TCP面向字节流，而UDP面向报文；
7. TCP是点对点连接的，而UDP一对一，一对多，多对多都可以；
8. TCP适合用于网页，邮件等，而UDP适合用于视频，语音广播等。

## HTTP

HTTP协议是**超文本传输协议**的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议，属于OSI网络模型中的第七层应用层协议。

### HTTP特点

1. http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。
2. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。
3. 灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。
4. 无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。
5. 无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。

### URI和URL的区别

HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。

- URI：Uniform Resource Identifier 统一资源**标识**符
- URL：Uniform Resource Location 统一资源**定位**符

URI 是用来标示 一个具体的资源的，我们可以通过 URI 知道一个资源是什么。 

URL 则是用来定位具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的URL。

### HTTP中GET与POST的区别？

1. GET从指定的资源请求数据，POST向指定的资源提交要被处理的数据；
2. GET请求有长度限制，而POST没有；
3. GET的安全性较差，而POST比GET更安全
4. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留；
5. GET请求能被缓存、收藏为书签，而POST不能；
6. GET请求只能进行url编码，而POST支持多种编码方式
7. GET数据在URL中对所有人都是可见的，而POST数据不会显示在URL中；
8. GET和POST本质上就是TCP连接，但GET产生一个TCP数据包，而POST产生两个TCP数据包。

### HTTP 状态码

- 1XX（临时响应）：表示临时响应并需要请求者继续执行操作的状态代码；

  - 100（继续）：请求者应当继续提出请求；
  - 101（切换协议）：请求者要求服务器切换协议；

- 2XX（成功）：表示成功处理了请求的状态代码；

- - 201（已创建）：请求成功并且服务器创建了新资源；
  - 202（已接受）：服务器已接受请求，但尚未处理；
  - 203（非授权信息）：服务器已成功处理了请求，但返回信息可能来自另一来源；
  - 204（无内容）：服务器成功处理了请求，但没有返回任何内容；
  - 205（重置内容）：服务器成功处理了请求，但没有返回内容，要求请求者重置内容；

- 3XX（重定向）：表示要完成请求，需要进一步操作；
- 300（多种选择）：针对请求，服务器可执行多种操作；
  - 301（永久移动）：请求的网页已永久移动到新位置；
  - 302（临时移动）：服务器目前从不同的位置的网页响应请求；
  - 304（未修改）：自从上次请求后，请求的网页未修改过；
  
- 4XX（请求错误）：表示请求可能出错，妨碍了服务器的处理；

- - 400（错误请求）：服务器不理解请求的语法；
  - 401（未授权）：请求要求身份验证；
  - 403（禁止）：服务器禁止请求；
  - 404（未找到）：服务器找不到请求的网页；

- 5XX（服务器错误）：表示服务器在尝试处理请求时发生内部错误；

  - 500（服务器内部错误）：服务器运到错误，无法完成请求；
  - 502（错误网关）：服务器作为网关或代理，从上游服务器收到无效响应；
  - 503（服务不可用）：服务器目前无法使用；
  - 504（网关超时）：服务器作为网关或代理，但是没有及时从上游服务器收到请求。

### KeepAlive

在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。
使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。
但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。

## HTTPS
一般http中存在如下问题：
- 请求信息明文传输，容易被窃听截取。
- 数据的完整性未校验，容易被篡改
- 没有验证对方身份，存在冒充危险

为了解决上述HTTP存在的问题，就用到了HTTPS。

HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。

### SSL
（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。

### TLS
（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。

### 流程
![https传输流程](./assets/https.jpg)

首先客户端通过URL访问服务器建立SSL连接。
服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。
客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
服务器利用自己的私钥解密出会话密钥。
服务器利用会话密钥加密与客户端之间的通信。

### HTTPS的缺点

HTTPS协议多次握手，导致页面的加载时间延长近50%；
HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；
申请SSL证书需要钱，功能越强大的证书费用越高。
SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。

### HTTPS和HTTP的区别
HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。

## 浏览器存储
共同点：都是保存在浏览器端，并且是同源的
### Cookie
cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题，存储容量小，只有大约4K左右）

### sessionStorage
仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个会话过程，关闭浏览器后消失，session为一个会话，当页面不同即使是同一页面打开两次，也被视为同一次会话）

### localStorage
localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效；永久存储数据，不要存放敏感数据）

### Cookie如何防范XSS攻击

XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie：
- httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。
- secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。
结果应该是这样的：`Set-Cookie=<cookie-value>.....`

### 注
cookie的作用：
1. 保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。

2. 跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。

Cookie和session的区别：
HTTP是一个无状态协议，因此Cookie的最大的作用就是存储sessionId用来唯一标识用户

## CDN

CDN的全称是Content Delivery Network，即内容分发网络。CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应。

## 跨域

[不要再问我跨域的问题了](https://segmentfault.com/a/1190000015597029)
### 同源策略

浏览器的同源策略导致了跨域，浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对Dom的查询。
1. 没有同源策略限制的接口请求，导致恶意网站向原网站发起了恶意请求（还能根据原网站Cookies请求），导致CSRF攻击
2. 没有同源策略限制的Dom查询，导致恶意网站拿到原网站的Dom，欺骗用户输入信息

### 什么是跨域？

概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。

```
URL                      说明       是否允许通信

http://www.a.com/a.js http://www.a.com/b.js     同一域名下   允许
http://www.a.com/lab/a.js	http://www.a.com/script/b.js 同一域名下不同文件夹 允许
http://www.a.com:8000/a.js	http://www.a.com/b.js     同一域名，不同端口  不允许
http://www.a.com/a.js	https://www.a.com/b.js 同一域名，不同协议 不允许
http://www.a.com/a.js	http://70.32.92.74/b.js 域名和域名对应ip 不允许
http://www.a.com/a.js	http://script.a.com/b.js 主域相同，子域不同 不允许
http://www.a.com/a.js	http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）
http://www.cnblogs.com/a.js	http://www.a.com/b.js 不同域名 不允许
```

对于端口和协议的不同，只能通过后台来解决
#### 同源策略限制下接口请求的正确打开方式

##### JSONP
JSONP（JSON with Padding）是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料。
JSONP也叫填充式JSON，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON，例如：
`callback({"name","trigkit4"});`
JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。

##### 空iframe加form
JSONP只能发GET请求，因为本质上script加载资源就是GET，那么如果要发POST请求需要空iframe加form

##### CORS
CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）跨域资源共享 CORS 详解。看名字就知道这是处理跨域问题的标准做法。CORS有两种请求，简单请求和非简单请求。

##### nginx代理
请求的时候还是用前端的域名，然后nginx代理服务器帮我们把这个请求转发到真正的后端域名上，避免跨域

#### 同源策略限制下Dom查询的正确打开方式

##### postMessage
window.postMessage() 是HTML5的一个接口，专注实现不同窗口不同页面的跨域通讯。

##### document.domain
这种方式只适合主域名相同，但子域名不同的iframe跨域。
比如主域名是http://crossdomain.com:9099 ，子域名是http://child.crossdomain.com:9099 ，这种情况下给两个页面指定一下document.domain即document.domain = crossdomain.com就可以访问各自的window对象了。

